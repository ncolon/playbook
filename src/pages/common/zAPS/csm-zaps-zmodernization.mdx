---
title: zSystems Application Modernization
description: zSystems Application Modernization
---

<AnchorLinks small>

  <AnchorLink>What are the pain points that zSystems Modernization addresses?</AnchorLink>
  <AnchorLink>Why application-centric patterns</AnchorLink>
  <AnchorLink>What are application-centric patterns</AnchorLink>
  <AnchorLink>Modernization for Optimization</AnchorLink>
  <AnchorLink>zSystems App Modernization Examples</AnchorLink>
  <AnchorLink>CSM Driven zSystems App Mod</AnchorLink>
  <AnchorLink>CSM Enablement</AnchorLink>

</AnchorLinks>

<Row>
<Column colMd={7} colLg={7}>

## What are the pain points that zSystems Modernization addresses?
* Legacy back-office systems lack business agility and inhibit digital transformation
* Mainframe code maintenance is costly
* Mainframe culture lacks agility needed to transform digitally
* Knowledge continuity risk exists due to limited bench, skillset and retiring workforce
* Investment decisions are difficult when considering mainframe refresh versus cloud migration off platform
* No holistic strategy on how to maximize mainframe and seamlessly incorporate it into hybrid cloud vision


## Why Application centric patterns
Drive enhanced function and flexibility through new application components that are developed as cloud-native functions, which either extend or enhance application components. New application components can either invoke applications on IBM zSystems or the applications can also invoke these new cloud-native functions.


## What are Application centric patterns
* **Expose** applications and data through APIs.
* **Extend** existing core applications on z/OS with Cloud Native applications.
* **Enhance (Rewrite)** selected functions incrementally as Cloud Native.
* **Colocate** applications close to existing IBM Z applications and data leveraging containers.

IBM zSystems delivers new hardware features that are specifically designed to improve performance of business-critical applications written in COBOL and PL/I. These applications are often complex and monolithic in nature, and an incremental approach to modernization is recommended. This approach is recommended because re-writing the entire application is very costly and poses a high risk to the business. Therefore, it is important to utilize the latest COBOL or PL/I compilers to optimize the performance and operating costs of your business-critical applications. You can also use new language features shipped in these compilers to extend the capabilities of your existing applications.

Application patterns address the different ways you can modernize and enhance an existing monolithic application. These patterns range in scope from minimal change of the existing application to a complete rewrite of the application using Cloud Native development methods based on microservices.

One of the more common application patterns on IBM zSystems is to expose existing applications and data through APIs. Managing via APIs provides simple but managed API-based access to mainframe applications to the applications without the risk of costly changes to the applications. Extending or enhancing an existing application involves implementing a new containerized service in a new programming language and consuming that new service from the original application. This is a great approach to accelerate change leveraging modern languages, Cloud Native programming techniques while broadening your developer resource pool beyond mainframe skilled resources.

As organizations transition to digital and online technologies the need to use more popular programming language with widely available skills for application development is becoming more critical. The IBM Open Enterprise language portfolio brings popular programming languages like Java, Go, Node.js and Python onto the z/OS platform. These programming languages come with many packages and frameworks that can help you get started and deliver enhancements quickly. While a new open enterprise language based function can be developed as a cloud-native application (e.g. deployed on any cloud), there are many key considerations (i.e. lower latency, performance/throughput, security and lower TCOs) that may drive deploying this function in a collocated manner next to existing z/OS applications (see “Colocate” pattern). Additionally, it may be easier to develop the new open enterprise language-based function as a tightly integrated function and have direct access to SOR data (e.g., VSAM and other z/OS based data sources) and integrate under a global transaction scope. Alternatively, the new functions may be realized by a third-party packaged solution running on any cloud. Existing applications can easily invoke such a packaged solution using APIs. Finally, under some scenarios the new function can also be developed as COBOL based application that is deployed on the cloud.

When it comes to application modernization analyst firm Gartner suggests an 80:20 rule -- 80% of an application needs no changes and 20% needs to be modernized. In this case, refactoring code can be an effective way to address the 20% that needs to change. Refactoring involves restructuring or componentizing discrete functions within the existing code without changing functionality. The objective is to improve code quality, lower complexity, and make functions easier to modify and maintain in the future.

If there is a very high percentage of change needed for an application, then rewriting the application may be necessary. In this case, you may choose to rewrite the application using a modern program language with a cloud native, microservices-based approach which enables a broader pool of developers to participate.

Independent of the approach used to modernize an application you can decide where to place the application within the infrastructure assuming that the application is containerized. You can decide for example to host the application in close proximity to your data.  In that case, you can host the application on the same z/OS environment using the z/CX container service as an execution environment. You can also choose to host the application further away but still within the same hardware platform using Linux on IBM zSystems running Red Hat OpenShift with a high-speed connection to the data. Alternatively, you can host the application on a public cloud depending on the need for transaction integrity or latency. One popular use case we are seeing today: the client starts by building a new cloud app that accesses back-end mainframe data. The client may be running on AWS today but are experiencing performance and scaling issues due to latency. By leveraging a container platform like Red Hat OpenShift you have the option of easily moving or co-locating the application closer to the data by deploying on z Linux. Or moving even closer to the data leveraging the z/CX container environment on z/OS.
Together, application-centric patterns provide many options for addressing the scope of application modernization required while maintaining deployment flexibility, optimizing cost, and lowering risk.


## Modernization for Optimization
* Modern developers demand modern APIs and interoperability with new capabilities written in contemporary programming languages
* IBM zSystems is the core of business. Therefore, it is very important to ensure business critical applications in traditional languages like COBOL, PL/I, C/C++ and Java are taking full advantage of the latest functionality of IBM zSystems hardware.
* Developer consumable interfaces to your core business logic are imperative to drive innovation
* Innovation is required to compete in rapidly changing markets
* RESTful APIs are the open standard being used to transform businesses in these markets


## Application Modernization Patterns
### Enhance

Integrate third-party cloud-based commercial-off-the-shelf (COTS) solution with existing Systems of Record (SOR) assets for replacing existing UI solutions
  * Solution approach:
    * Expose APIs to access SOR application/data.
    * New cloud-based application, business solution integration, accesses SOR data and performs a variety of operations.
    * Receives updates from third-party solutions
    * Performs business validations (e.g. business rules) and additional functions (e.g. business process)
    * Performs transformations and invokes SOR data access APIs

  * **Benefits:** Improved customer experience by using a third-party lease expiry management solution while keeping data consistent with the Systems-of-Record data
    * Avoids a high-risk strategy and effort of having to rewrite all existing functions.
    * Real-time integration avoids manual, ad hoc and/or delayed process of synching up SOR data.
    * Solution is robust and has proven value with surge in peak workload due to the recent pandemic environment.

  * **Client example:** Toyota Financial Services - Use of Salesforce for lease expiration management by customers:
    * Customers can change lease expiry date and other related aspects
    * Customer and vehicle related SOR data is maintained on an IBM zSystem
    * Change in lease date can trigger change in payment schedule, etc.

### Extend

Extend selected functions of a SOR application with new Cloud Native functions
  * **Benefits:** Improved customer data which is shared with other business functions.
    * “Opening a savings account went from 2-3 days to 218 milliseconds!”
    * In the first 3 months, 5500 new savings accounts were opened, with over $150M on deposit.
  * **Client example:** Large Financial Organization - Accelerated account servicing
    * Real-time account provisioning by reducing account opening and provisioning time from days to milliseconds.
    * With new Cloud Native functions, an application delivered a new capability to customers for real-time processing

### Refactor and Colocate

Modernize selected core functions for standardization and agility by implementing as a cloud Native application
  * **Benefits:** Improved customer data which is shared with other business functions.
    * Optimized MIPs consumption due to externalization
    * Order of magnitude reduction in Batch window time due to colocation
    * Standardized core functions such as currency conversion, easily shared across LOB applications
  * **Client example:** Large financial organization
    * Modernizing batch application by refactoring embedded business functions for looking up less frequently changing customer information and currency conversion for agility and ease of sharing.


## IBM Open Enterprise Languages
You can develop an open enterprise language based function and collocate on the same environment as the existing application for tighter integration. Consider writing the new function using open enterprise languages, such as Go, Python, Node.js or Java if you want to exploit the following:
  * Simplification of development and deployment by leveraging package ecosystems support for open-enterprise languages and deployment tools. 
  * Interoperation with traditional z/OS high-level languages and reuse of existing functions written in COBOL, PL/I and Assembler.
  * Ability to exploit the pool of readily available developers that are familiar with development using modern languages, and the associated development environment
  * Tight integration with the existing system of record, enabling the new components to seamlessly extend the qualities of services of the existing runtime without complex design choices. This can provide global transaction recovery across traditional resource managers and modern XA based resources, robust security controls and auditing, exploitation of existing management tools like backup/restore and monitoring processes.
Although open enterprise languages can be used to build most anything, you need to consider the strengths of each programming language. 



### Java

If you are looking to extend a CICS or IMS program or interact with major subsystems or z/OS resources, then the preferred approach is to write the new function in Java. CICS and IMS provides Java class libraries (e.g., JCICS for CICS and IMS Universal Drivers for IMS) that make it easy to call native CICS and IMS resources using Java interfaces. Major subsystems like Db2, IMS DB and MQ provide open standards-based libraries based on JDBC and JMS specifications, and the z/OS operating system also provides the JZOS Java class library to simplify access to operating system resources and data. Furthermore, CICS and IMS provide a runtime environment for Java applications which makes it possible to run the new function and the existing application within the same recoverable unit of work (UOW), i.e., Global transaction scope. Lastly, Java provides support for interlanguage communication which makes it easy for Java to talk to existing COBOL and PL/I programs.

**Client example:** A national social security fund which provides consolidated benefits for all its citizens. In the initial phase, a new interactive application for citizens was implemented in Liberty with Spring MVC.  The main driver for that approach was a shortage of COBOL developers. The ability to use readily available Java development skills, frameworks and tooling made it an easy choice. In the past, new Java based functions were developed and deployed on a distributed platform. Integration of the overall solution included both MQ based integration of web applications with CICS applications, as well as web services-based integration of CICS based business logic invoked by Web UIs, hosted externally on a distributed platform.  In contrast, use of JCICS for COBOL/Java integration made it very easy in developing new Java based functions. It provided easy access to both persistent SOR data and common shared data across new and existing functions. Batch integration using Java applications was deployed into a Spring batch framework.  All data in Db2 were accessed using JDBC in CICS with global transaction support. Finally, IBM RTC, Jenkins, Junit, Maven build and IBM UCD were used for development.

**Client example:** An IT service provider introduced Java in IMS alongside COBOL in IMS on IBM zSystems to accelerate creation of new services and extend the life and value of their existing applications.  One of their banking clients, wanted to modernize their core banking application with an incremental approach. With the long-term goal of evolving the mainframe application infrastructure from COBOL-centric to Java-centric, they started out by examining their existing IMS landscape and identify the part that must be Java-enabled. Some of the requirements to write Java IMS applications are (a) the ability to handle the Unit of Work across IMS DB, Db2 for z/OS and IBM MQ; (b) have the ability to cascading calls (from COBOL to Java to COBOL to Java); (c) ability to exchange data between COBOL and Java in an efficient way; (d) output from COBOL and Java must appear chronologically in the same Job or application output; and (e) errors in Java must be percolated back to IMS. With Java in IMS, the IT service provider was able to establish Java as the next-generation language for the mainframe and helped their banking client modernized their banking application.

### Node.js

Node.js is designed to build scalable network applications. Therefore, it is best suited for I/O intensive applications. It has over 1.5M good-to-go packages to help accelerate software delivery. It provides a highly scalable, module-driven approach to software development that encourages agile practices.  You can use Node.js to securely aggregate data on z/OS and implement APIs for report generation or enable dashboard applications. It is also a good choice for API orchestration where business logic is required. Node.js can run as a standalone z/OS application or as a CICS application. 

**Client example:**  A major bank is leveraging Node.js for z/OS (deployed in CICS) to deliver a modern application experience.  The former 3270 green-screen user interface has been transformed into a browser-based experience for users.  It is now much easier to trigger CICS transactions, and also to maintain and update the new Node.js application.  Furthermore, the Node.js application easily allows the use of RESTful APIs to call other API services within the z/OS system and to external services.

**Client example:** A software vendor is using Node.js to modernize a legacy license management system. Using Node.js' strength as a web application development platform, a RESTful interface to an existing REXX application was developed. While initially simplifying and modernizing the application itself, it was rapidly extended to enable new functionality unlocked by the ability to interact with the application using the RESTful interface, all while maintaining the existing application investment.


### Python

Python is ideal for data science applications. You can use it with Python AI Tookkit for z/OS to perform advance data collation, analysis, and visualization on z/OS where data is stored. You can also streamline automation for applications deployment and IT infrastructure with Ansible, and DevOps processes. You can also use Python can to develop new API to interoperate with critical applications running on and off of z/OS and take advantage of colocation.

**Client Example:** A major American Bank leveraged Python and its powerful data analysis packages to combine internal (datasets, databases, application output), and external (RESTful API data consumption from SalesForce) right on their z/OS host.  This permitted the customer to develop novel views of their business via analysis spanning multiple internal and external applications, all from the safety of the z/OS environment.  Python's strength as a quick prototyping language enabled the rapid development, refinement, and convergence on valuable new insights.  Python was subsequently used to persist the results of this processing to a new database.

**Client Example:**  A major communications company leveraged Python's strength in data analytics, visualization, and web application development in their z/OS environment.  It was used to post-process data coming from  existing applications.  Specifically, Python was used to perform analytics, identify trends and generate visualization graphs and images of those trends right on host.  The data was then presented via a Python web application hosted on the z/OS host, which is now being used to better understand important developments in the business.


### Go (or Golang)

Go is a general-purpose programming language for building large-scale complex applications. It has a powerful standard library of packages and built-in functions to support application development.  Go is a compiled language which generates high performance code in z/OS.  It is ideal for developing new applications or APIs to extend existing business critical applications on z/OS. You can also use Go to enable popular applications on z/OS. Go applications can interoperate with applications written in other languages (e.g. COBOL, PL/I, C/C++, and Java) via cgo and IBM middleware via APIs developed with z/OS connect.

**Client Example:** An enterprise software company enhanced a common shared function for ease-of-use and faster performance. It leveraged Go to increase the performance of a frequently used command-line function to calculate and verify 128-bit MD5 hashes. This hash is used as a digital signature to identify and verify the integrity of a file. This function is used as a part of a file synchronization process between z/OS and a workstation, where MD5 hashes are calculated at each endpoint. This facilitates the verification process to identify files quickly, without the need to transfer data between the systems for comparison. This function enhancement has produced significant increase in performance, decrease in I/O, and load reduction of the general processor.

**Client Example:** An independent software vendor (ISV) is porting a Go-based analytics and interactive visualization web application. Clients could not effectively monitor and gather data analytics for process improvement in a single unified platform. With this software ported to the zSystems platform, now clients can leverage this application to monitor and manage all their cross-platform applications in a single unified location.

## CSM Driven zSystems Application Modernization
| Activity | Goals | Actors | Desired Outcome | Additional Resources |
| ---------- | ----------- | ----------- | ----------- | ----------- |
| 1. App Mod Tools in Customer ELA | Identify App Mod opportunity from what’s in the catalog | • IBM CSM | • Discover App Mod opportunities |  |
| 2. Application Modernization | Get customer to understand options for App Mod and the value vs re-write. | • IBM CSM <br /> • Customer <br /> • GTM Teams | • Customer wants to move forward for an App Mod Workshop | GTM Sales teams; Allison Grayson |
| 3. App Mod Workshop | Set of recommendation of best modernization approach and a plan | • IBM CSM <br /> • IBM Technology Expert Labs <br /> • Customer | • Customer has a firm understanding of what it takes for modernizing their application | Z  Modernization Advisory Team (zMAT); Joanie Gines |
| 4. Proof of value | Proof that modernization can work as promised | • IBM CSM <br /> • IBM Technology Expert Labs <br /> • Customer | • Customer can confirm the value as promised |  |
| 5. Roll out | Full Application and processes in Production | • IBM CSM <br /> • IBM Technology Expert Labs <br /> • Customer | • Application along with |  |
| 6. Expand and Grow | Prospect for new opportunities for app mod with other dev teams | • IBM CSM <br /> • Account Team | • Uncover new opportunities |  |


## CSM Enablement

* Unlock the value of the IBM Z mainframe Level 1: https://yourlearning.ibm.com/activity/PLAN-F84C0EA681A1
* Application Modernization on IBM Z Level 2: https://yourlearning.ibm.com/activity/PLAN-1A124A3143BC/track-progress?planIdFromParentTab=PLAN-5F912B2BB02B&sectionIdFromParentTab=SECTION-A&planIdForChildTab=PLAN-1A124A3143BC
* zDevops CI/CD Pipeline with Product Mapping: https://ibm.box.com/s/02h2xuyws50xeth70iii6jq9fd4k4wtn
* Z Software Skills website: https://w3.ibm.com/w3publisher/zsoftwarelearningpath
* Z Skills DevOps page: https://w3.ibm.com/w3publisher/zsoftwarelearningpath/what-we-build/enterprise-devops
* DevOps Overview in Your Learning: https://yourlearning.ibm.com/activity/PLAN-E500F6B3DD99
* ADDI Foundational learning:https://yourlearning.ibm.com/activity/PLAN-712A753DAC3C
* Discovery and Planning Content solution page: https://www.ibm.com/support/z-content-solutions/discovery-plan/

**CICS**
- Learning Path: https://w3.ibm.com/w3publisher/apprentice-and-cics/learning-path
- Introduction to CICS: https://yourlearning.ibm.com/activity/URL-C08BGMDWPIO  (3 hours)
- Modernize applications with IBM CICS: https://yourlearning.ibm.com/activity/ITS-DL000027G  (3 hours)
- CICS: What is it and why do I care? https://yourlearning.ibm.com/activity/IEC-10242605  (1 hour)
- CICS Application Programming using IMS, Db2 and MQ: https://yourlearning.ibm.com/activity/IEC-10233640  (2 hours)
- IBM TechU DevOps for IBM Z: https://yourlearning.ibm.com/activity/ITS-TU00026G  (5 hours)
- IBM TechU IMS for System Z: https://yourlearning.ibm.com/activity/ITS-TU00025G  (8 hours)

**IMS**
- What is IMS? https://yourlearning.ibm.com/activity/URL-C8EFF741901A  (30 min)
- IBM IMS for Dummies: https://yourlearning.ibm.com/activity/URL-B553AC409E61  (30 min)
- IMS Fundamentals: https://learn.ibm.com/course/view.php?id=8829
- IMS Database Fundamentals: https://learn.ibm.com/course/view.php?id=10118
- Java application development for IMS: https://www.ibm.com/docs/en/ims/15.2.0?topic=programming-java-application-development-ims

**IBM Open Enterprise Languages https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.1?topic=enhance-zos-applications-open-enterprise-languages**
- IBM Open Enterprise SDK for Python https://www.ibm.com/products/open-enterprise-python-zos
- IBM Open Enterprise SDK for Node.js https://www.ibm.com/products/sdk-nodejs-compiler-zos
- IBM Open Enterprise SDK for Go https://www.ibm.com/products/open-enterprise-sdk-go-zos
- IBM Semeru (Java) Runtime Certified Edition for z/OS https://www.ibm.com/products/semeru-runtime-certified-zos

</Column>
<Column colMd={5} colLg={5}>

<br/><br/>

<Aside>

**Strategy**

<a href='https://ibm.seismic.com/Link/Content/DCgbbVPpppJ6C89B8qbMVMVQ8XfB' target='_blank' rel='noreferrer noopener'>Sales Kit: Application Modernization with IBM Z and Cloud</a><br/>
<a href='https://ibm.seismic.com/Link/Content/DCHGgjF8dhMm789J2TBMqFVd4mQj' target='_blank' rel='noreferrer noopener'>Create and Modernize Applications with DevOps envisioned for Hybrid Cloud</a>

</Aside>

<Aside>

**Seller enablement**

<a href='https://ibm.seismic.com/Link/Content/DCf49836e7-7211-46b4-a2b8-e3795848968e' target='_blank' rel='noreferrer noopener'>Accelerate application modernization with IBM Z and Cloud</a><br/>
<a href='' target='_blank' rel='noreferrer noopener'>Continuously modernize with DevOps video</a><br/>
<a href='https://ibm.seismic.com/Link/Content/DCdb0ad2e5-84d8-41ef-b18d-b7800ea7a116' target='_blank' rel='noreferrer noopener'>Application discovery and
business alignment</a><br/>
<a href='https://ibm.seismic.com/Link/Content/DC71d05e5a-237d-4d18-a08d-1aa1284e8578' target='_blank' rel='noreferrer noopener'>Application discovery and
business alignment video</a>

</Aside>

<Aside>

**Product pages**

<a href='https://www.ibm.com/products/app-discovery-and-delivery-intelligence' target='_blank' rel='noreferrer noopener'>IBM Application Discovery and Delivery Intelligence</a>

<a href='https://www.ibm.com/products/z-and-cloud-modernization-stack' target='_blank' rel='noreferrer noopener'>IBM Z and Cloud Modernization Stack</a>
</Aside>

<Aside>

**Learning**

<a href='https://yourlearning.ibm.com/activity/PLAN-1A124A3143BC' target='_blank' rel='noreferrer noopener'>Application Modernization on IBM Z Level 2</a>

</Aside>

<Aside>

**Partners**

**HCL**
<a href='https://www.hcl-software.com/hclsw-home' target='_blank' rel='noreferrer noopener'>HCL Software</a>

**Rocket**
<a href='https://www.rocketsoftware.com/' target='_blank' rel='noreferrer noopener'>Rocket Software</a>
<a href='https://form.jotform.com/231643749170357' target='_blank' rel='noreferrer noopener'>Rocket Software intake form</a>





</Aside>

</Column>
</Row>
